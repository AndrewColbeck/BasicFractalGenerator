/*
* Generated by SGWrapperGen - DO NOT EDIT!
*
* SwinGame wrapper for C - Networking
*
* Wrapping sgNetworking.pas
*/

#ifndef sgNetworking
#define sgNetworking

#include <stdint.h>

#ifndef __cplusplus
  #include <stdbool.h>
#endif

#include "Types.h"

void broadcast_message(const char *aMsg);
void broadcast_message_to_server_named(const char *aMsg, const char *name);
void broadcast_message_to_server(const char *aMsg, server_socket svr);
void check_network_activity();
void server_clear_messages(server_socket svr);
void connection_clear_messages(connection aConnection);
void clear_messages_named(const char *name);
void close_all_connections();
void close_all_servers();
void close_all_udpsockets();
bool close_connection(connection *aConnection);
bool close_connection_named(const char *name);
void close_message(message msg);
bool close_server(server_socket *svr);
bool close_server_named(const char *name);
bool close_udpsocket(unsigned short int aPort);
int32_t connection_count_for_server_named(const char *name);
int32_t connection_count(server_socket server);
uint32_t connection_ipnamed(const char *name);
uint32_t connection_ip(connection aConnection);
connection connection_named(const char *name);
bool connection_open(connection con);
bool connection_open_named(const char *name);
unsigned short int connection_port(connection aConnection);
unsigned short int connection_port_named(const char *name);
server_socket create_server(const char *name, unsigned short int port);
server_socket create_server_with_protocol(const char *name, unsigned short int port, connection_type protocol);
void dec_to_hex(uint32_t aDec, char *result);
void free_connection(connection *aConnection);
void free_server(server_socket *svr);
bool has_messages();
bool has_message_on_connection(connection con);
bool has_message_on_server(server_socket svr);
bool has_message_on_connection_named(const char *name);
bool has_new_connections();
void hex_str_to_ipv4(const char *aHex, char *result);
void hex_to_dec_string(const char *aHex, char *result);
uint32_t ipv4_to_dec(const char *aIP);
void ipv4_to_str(uint32_t ip, char *result);
connection last_connection(server_socket server);
connection last_connection_for_server_named(const char *name);
connection message_connection(message msg);
int32_t connection_message_count(connection aConnection);
int32_t message_count_on_connection_named(const char *name);
int32_t server_message_count(server_socket svr);
void message_data(message msg, char *result);
void message_host(message msg, char *result);
unsigned short int message_port(message msg);
connection_type message_protocol(message msg);
void my_ip(char *result);
connection open_connection(const char *host, unsigned short int port);
connection open_connection_named(const char *name, const char *host, unsigned short int port);
connection open_connection_named_with_protocol(const char *name, const char *host, unsigned short int port, connection_type protocol);
message read_message(connection aConnection);
message read_message_named(const char *name);
message read_message_from_server(server_socket svr);
void read_message_data(connection aConnection, char *result);
void read_message_data_from_server(server_socket svr, char *result);
void read_message_data_named(const char *name, char *result);
void reconnect_connection_named(const char *name);
void reconnect(connection aConnection);
void release_all_connections();
connection retrieve_connection_from_server_named(const char *name, int32_t idx);
connection retreive_connection(server_socket server, int32_t idx);
bool send_message_to(const char *aMsg, connection aConnection);
bool send_message_to_connection_named(const char *aMsg, const char *name);
bool server_named_has_new_connection(const char *name);
bool server_has_new_connection(server_socket server);
server_socket server_named(const char *name);
void set_udppacket_size(int32_t val);
int32_t udppacket_size();

#ifdef __cplusplus
// C++ overloaded functions
void broadcast_message(const char *aMsg, const char *name);
void broadcast_message(const char *aMsg, server_socket svr);
void clear_messages(server_socket svr);
void clear_messages(connection aConnection);
void clear_messages(const char *name);
bool close_connection(connection &aConnection);
bool close_connection(const char *name);
bool close_server(server_socket &svr);
bool close_server(const char *name);
int32_t connection_count(const char *name);
uint32_t connection_ip(const char *name);
bool connection_open(const char *name);
unsigned short int connection_port(const char *name);
server_socket create_server(const char *name, unsigned short int port, connection_type protocol);
void free_connection(connection &aConnection);
void free_server(server_socket &svr);
bool has_messages(connection con);
bool has_messages(server_socket svr);
bool has_messages(const char *name);
connection last_connection(const char *name);
int32_t message_count(connection aConnection);
int32_t message_count(const char *name);
int32_t message_count(server_socket svr);
connection open_connection(const char *name, const char *host, unsigned short int port);
connection open_connection(const char *name, const char *host, unsigned short int port, connection_type protocol);
message read_message(const char *name);
message read_message(server_socket svr);
void read_message_data(server_socket svr, char *result);
void read_message_data(const char *name, char *result);
void reconnect(const char *name);
connection retreive_connection(const char *name, int32_t idx);
bool send_message_to(const char *aMsg, const char *name);
bool server_has_new_connection(const char *name);

#endif

#endif

